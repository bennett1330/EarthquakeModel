{
    "collab_server" : "",
    "contents" : "##########################################################################################\n###\n### EarthquakeModeling.R\n### MATH3800: Stochastic Processes\n###\n### Final\n### Project:  Earth Quake Prediction Modeling\n###\n### Authors:  Matt Bennett (bennetts4@wit.edu)\n###           Kai Yuen Fong\n###           Simranjit Singh\n###           Ichiryu Nakashima\n###\n### Summary:  Simulation of major earthquake occurances in the Southern California region\n###           using data files obtained from CalTech: Division of Geological and Planetary\n###           Sciences. (Simulation of other data sets may require changes to the parsing\n###           and structuring of the global data variable.)\n###           \n##########################################################################################\n\n### Required for map display functions:\n###   Tools -> Install Packages => ggmap from repository\n###   Tools -> Install Packages => mapproj from repository\n###\n### NOTE: LIBRARY AND PROVIDED FUNCTIONS USE LON, LAT\nlibrary( ggmap )\nlibrary( mapproj )\n\n### NOTE: DATA FILES MUST BE IN YOUR WORKING DIRECTORY\nworkingDirectory = \"C:/Users/bennetts4/Google Drive/zCompleted_Courses/MATH3800_StochasticProcesses/Stochastics_Project/DataFiles\";\n\n# Number of years to simulate\nt = 50;\n\n# Boundaries of data set\nstartYear = 1932;    endYear = 2016;\nminLat = 31.999;     maxLat = 37.001;\nminLon = -122.001;   maxLon = -113.999;\n\n# Information on how to structure the data\nminMag = 3;\nmainShockPercent = 0.95;\nrows = 8;      columns = 8;\nsubrows = 4;   subcolumns = 4;\n\n# Conversions of structural data\nstartDate = as.Date( paste( startYear, \"-01-01\", sep=\"\" ) );\nendDate = as.Date( paste( endYear, \"-01-01\", sep=\"\" ) );\ndeltaLat = ( maxLat - minLat ) / columns;\ndeltaLon = ( maxLon - minLon ) / rows;\nsubDeltaLat = deltaLat / subcolumns;\nsubDeltaLon = deltaLon / subrows;\n\n### Parse earthquake data from text files startYear.txt through endYear.txt in \n### working directory\n###\n### Global      rawData      data frame      \nparseData = function(){\n    data = c();\n    for ( year in startYear:endYear ){\n        fileData = read.table( paste(year, \".txt\", sep = \"\"), header = TRUE );\n        data = rbind( data, fileData );\n    }\n    rawData <<- data; # make rawData available as global variable in R\n    print( \"Data parsed from files.\" );\n    return( rawData );\n}\n\n### Clean and structure data for use with R functions.\n###\n### Global      data        data frame      provided data with unused data and\n###                                         information removed, data types altered,\n###                                         and information for calculations added\n###                                         in new columns\nstructureData = function( data ){\n    data = subset( data, ( data$MAG > minMag ) );\n    data$YYY.MM.DD = as.Date( data$YYY.MM.DD );\n    data$DATE = data$YYY.MM.DD;\n\n    data$YYY.MM.DD = NULL;   data$HH.mm.SS.ss = NULL;   data$DEPTH = NULL;\n    data$ET = NULL;          data$GT = NULL;            data$NGRM = NULL;\n    data$M = NULL;           data$Q = NULL;             data$NPH = NULL;\n    \n    data = createGridData( data );\n    data = createEventData( data );\n    data = createQuantileData( data );\n    data = createLambdaData( data );\n    data <<- data # make structured data available as global variable in R\n    print( \"Data structured and cleaned.\" );\n    return( data );\n}\n\n\n\n### Add row and column, and subrow, subcolumn, information to the data set.\n###\n### Global      data        data frame      provided data with additional\n###                                         information for region\ncreateGridData = function( data ){\n    data$COLUMN = ceiling( ( data$LAT - minLat ) / deltaLat );\n    data$ROW = ceiling( ( maxLon - data$LON ) / deltaLon );\n    data$SUBCOLUMN = ceiling( ( data$LAT - minLat ) / subDeltaLat ) %% subcolumns + 1;\n    data$SUBROW = ceiling( ( maxLon - data$LON ) / subDeltaLon ) %% subrows + 1;\n    return( data );\n}\n\n### Access all the occurances in the provided data set of the given row and column \n### or of the row, column, subrow, and subcolumn.\n###\n### Local       data        data frame      all data from input data within the\n###                                         specified section of the overall\n###                                         region           \ngetCellData = function( data, column, row, subcolumn, subrow ){\n    data = subset( data, ( data$COLUMN == column ) & ( data$ROW == row ) );\n    if ( missing( subcolumn ) | missing( subrow ) ){\n        return( data );\n    } else{\n        data = subset( data, ( data$SUBCOLUMN == subcolumn ) & \n                           ( data$SUBROW == subrow ) );\n        return( data );\n    }\n}\n\n### Determine event defining earthquakes and cluster nearby foreshocks and after\n### shocks together with the event using a event idenifier.\n### \n### Local       eventData   data frame      all data from input data with event\n###                                         column added with subsets of matching \n###                                         interger event identifiers\n###                                         representing a clustered event.\n###\ncreateEventTriggers = function( data ){\n    eventData = c();\n    for ( row in 1:rows ){ for ( column in 1:columns ){\n        for ( r in 1:subrows ){ for ( c in 1:subcolumns ){\n            subcell = getCellData( data, column, row, c, r );\n            threshold = quantile( subcell$MAG, prob = mainShockPercent )\n            mainShock = subset( subcell, ( subcell$MAG >= threshold ) );\n            eventData = rbind( eventData, mainShock );\n        }}\n    }}\n    eventData = eventData[ !( \n            duplicated( eventData$DATE ) & \n            duplicated( eventData$COLUMN ) & duplicated( eventData$ROW ) & \n            duplicated( eventData$SUBCOLUMN ) & duplicated( eventData$SUBROW ) \n    ), ];\n    eventData = eventData[ with( eventData, order( DATE, MAG) ), ];\n    eventData$EVENT = c( 1:nrow( eventData ) );\n    return( eventData );\n}\n\n###\n###\n###\ncreateEventData = function( data ){\n    data$EVENT = -1;\n    eventData = createEventTriggers( data );\n    data = data[ with( data, order( DATE, MAG) ), ];\n    for ( e in 1:nrow( eventData ) ){\n        data$EVENT[ data$EVID == eventData$EVID[ e ] ] = eventData$EVENT[ e ];\n        subcell = getCellData( data, eventData$COLUMN[ e ], eventData$ROW[ e ], \n                               eventData$SUBCOLUMN[ e ], eventData$SUBROW[ e ] );\n        if ( nrow( subcell ) != 0 ){\n            for ( i in 1:nrow( subcell ) ){\n                if ( ( subcell$DATE[ i ] >= eventData$DATE[ e ] - 3 ) & \n                     ( subcell$DATE[ i ] <= eventData$DATE[ e ] + 3 ) ){\n                    data$EVENT[ data$EVID == subcell$EVID[ i ] \n                                ] = eventData$EVENT[ e ];\n                }   }   }\n    }\n    return( data );\n}\n\n###\n###\n###\ngetEventTriggers = function( data, column, row ){\n    eventData = c();\n    if ( missing( column ) || missing( row ) ){\n        for ( c in 1:columns ){ for ( r in 1:rows ){\n            cell = getCellData( data, c, r );\n            t = getEventTriggers( cell, c, r );\n            if ( is.null( eventData ) ){\n                eventData = t;\n            }else {\n                eventData = rbind( eventData, t );\n            }\n        }}\n    }else {\n        cell = getCellData( data, column, row );\n        u = as.data.frame( unique( cell$EVENT ) );\n        u = subset( u, u[ , 1] > 0 );\n        for ( i in 1:nrow( u ) ){\n            e = subset( cell, cell$EVENT == u[ i, ] );\n            if ( nrow( e ) != 0 ){\n                t = subset( e, e$MAG == max( e$MAG ) );\n                if ( is.null( eventData ) ){\n                    eventData = t;\n                }else {\n                    eventData = rbind( eventData, t );\n                }\n            }\n        }\n    }\n    return( eventData );\n}\n\n###\n###\n###\ncreateQuantileData = function( data ){\n    data$QUANT = 0;\n    for ( row in 1:rows ){ for ( column in 1:columns ){\n        cell = getCellData( data, column, row );\n        if ( nrow( cell ) != 0 ){\n            cell$QUANT = quantile( cell$MAG, prob = mainShockPercent );\n            for ( i in 1:nrow( cell ) ){\n                data$QUANT[ data$EVID == cell$EVID[ i ] ] = cell$QUANT[ i ];\n            }\n        }\n    }}\n    return( data );\n}\n\n###\n###\n###\ncreateLambdaData = function( data ){\n    data$LAMBDA = 0;\n    for ( row in 1:rows ){ for ( column in 1:columns ){\n        cell = getCellData( data, column, row );\n        if ( nrow( cell ) != 0 ){\n            cell$LAMBDA = getCellLambda( cell );\n            for ( i in 1:nrow( cell ) ){\n                data$LAMBDA[ data$EVID == cell$EVID[ i ] ] = cell$LAMBDA[ i ];\n            }\n        }\n    }}\n    return( data );\n}\n\n###\n###\n###\ngetCellLambda = function( cell ){\n    if ( nrow( cell ) == 0 ){\n        ilambda = 0;\n    } else{\n        events = getEventTriggers( cell );\n        if ( is.null( events ) ){\n            ilambda = 0;\n        }else if ( nrow( events ) > 4 ){\n            ilambda = 365 / (as.numeric( max( events$DATE ) - min( events$DATE ) ) / nrow( events ) - 1 );\n        } else{\n            ilambda = 365 / as.numeric( endDate - startDate ) / nrow( events );\n        }\n    }\n    return( ilambda );\n}\n\n\n\n###\n###\n###\ngetCellQMean = function( cell ){\n    cell = getEventTriggers( cell );\n    cell = subset( cell, cell$MAG > cell$QUANT );\n    if ( is.null( cell ) || (nrow( cell ) == 0) ){\n        avg = 0;\n    } else{\n        avg = mean( cell$MAG );\n    }\n    return( avg );\n}\n\n###\n###\n###\ngetCellMag = function( cell ){\n    cell = getEventTriggers( cell );\n    if ( is.null( cell ) || (nrow( cell ) == 0) ){\n        mag = NULL;\n    }else{\n        Q = cell$QUANT[ 1 ];\n        EM = getCellQMean( cell );\n        if ( (Q == 0) || (EM == 0) ){\n            mag = NULL;\n        } else{\n            R = runif( 1, min = 0, max = 1 );\n            mag = Q - ( EM - Q ) * log( 1 - R );\n        }\n    }\n    return( mag );\n}\n\ngetPois = function( cell ){\n    lambda = getCellLambda( cell );\n    v = runif( rpois( 1, lambda * t ), min = 0, max = t );\n    v = sort( v );\n    # plot( stepfun( v, 0:length( v ) ) );\n    # print( length( v ) );\n    # print( v );\n    return( v );\n}\n\n###\n###\n###\nplotGridData = function( data ){\n    par( mfrow = c( columns, rows ), oma = c( 1, 1, 0, 0 ),\n         mar = c( 1, 1, 1, 0 ), tcl = -0.1, mgp = c( 0, 0, 0 ) \n    );\n    for ( r in 1:rows ){ for ( c in 1:columns ){\n        d = subset( data, ( data$COLUMN == c ) & ( data$ROW == r ) );\n        if( nrow( d ) != 0 ){\n            p = plot( d$DATE, d$MAG, ylim = c( minMag - 0.2, 8 ), \n                      xlim = c( startDate, endDate ) );\n        } else{\n            plot( 0, type=\"l\", ylim = c( minMag - 0.2, 8 ), \n                  xlim = c( startDate, endDate ) );\n        }\n    }}\n}\n\n###\n###\n###\n###\n###\n\n###\n###\n###\nplotSubGridData = function( data, column, row ){\n    par( mfrow = c( subcolumns, subrows ), oma = c( 1, 1, 0, 0 ),\n         mar = c( 1, 1, 1, 0 ), tcl = -0.1, mgp = c( 0, 0, 0 ) \n    );\n    for ( r in 1:subrows ){ for ( c in 1:subcolumns ){\n        s = getCellData( data, column, row, c, r );\n        if( nrow( s ) != 0 ){\n            p = plot( s$DATE, s$MAG );\n        } else{\n            plot( 0, type=\"l\" );\n        }\n    }}\n}\n\n###\n###\n###\nplotCellEvents = function( data, column, row ){\n    cell = getCellData( data, column, row );\n    if ( nrow( cell ) != 0 ){\n        triggers = getEventTriggers( cell );\n        plot( triggers$DATE, triggers$MAG, \n              xlim = c( startDate, endDate ),\n              ylim = c( minMag, 8 ) \n        );\n    }else {\n        plot( 0, type=\"l\", xlim = c( startDate, endDate ),\n              ylim = c( minMag, 8 ) );\n    }\n}\n\n###\n###\n###\nplotGridEvents = function( data ){\n    par( mfrow = c( columns, rows ), oma = c( 1, 1, 0, 0 ),\n         mar = c( 1, 1, 1, 0 ), tcl = -0.1, mgp = c( 0, 0, 0 ) \n    );\n    for ( r in 1:rows ){ for( c in 1:columns ){ \n        plotCellEvents( data, c, r );\n    }}\n}\n\n###\n###\n###\nplotPoisMag = function( cell ){\n    et = getPois( cell );\n    if ( is.null( et ) || (length( et ) == 0) ){\n        plot( 0, type=\"l\", xlim= c( 0, t ), ylim = c( 3, 8 ) );\n        grid( t/5, 5 );\n        return( NULL );\n    }\n    mag = c();\n    for ( e in 1:length( et ) ){\n        if ( length( mag ) == 0 ){\n            mag = getCellMag( cell );\n        } else{\n            mag = cbind( mag, getCellMag( cell ) );\n        }\n    }\n    if ( (length( et ) == 0) || is.null( mag ) ){\n        plot( 0, type=\"l\", xlim= c( 0, t ), ylim = c( 3, 8 ) );\n        grid( t/5, 5 );\n        return( NULL );\n    } else{\n        plot( et, mag, xlim= c( 0, t ), ylim = c( 3, 8 ) );\n        grid( t/5, 5 );\n    }\n    df = c(); \n    if ( length( mag ) == 1 ){\n        df$MAG = mag[ 1 ]; df$YEAR = et;\n    } else{\n        df$MAG = mag[ 1, ]; df$YEAR = et;\n    }\n    return( df );\n}\n\n###\n###\n###\nplotPoisMagGrid = function( data ){\n    par( mfrow = c( columns, rows ), oma = c( 1, 1, 0, 0 ),\n         mar = c( 1, 1, 1, 0 ), tcl = -0.1, mgp = c( 0, 0, 0 ) \n    );\n    simData = c();\n    for ( r in 1:rows ){ for( c in 1:columns ){\n        cell = getCellData( data, c, r );\n        result = c();\n        result = plotPoisMag( cell );\n\n        if ( is.null( result ) || (length( result ) == 0) ){\n            #pass\n        } else if ( is.null( simData ) || (length( simData ) == 0) ){\n            result$COLUMN = c;\n            result$ROW = r;\n            simData = as.data.frame( result );\n        } else{\n            result$COLUMN = c;\n            result$ROW = r;\n            simData = merge.data.frame( simData, as.data.frame( result ), all = TRUE );\n        }\n        simData <<- simData;\n    }}\n    print( paste( \"Simulation of \", t, \" years complete.\", sep=\"\" ) );\n    View( simData );\n}\n\n###\n###\n###\nmapGrid = function( simData ){\n    mg = c();\n    for ( r in 1:rows ){ for ( c in 1:columns ){\n        cell = getCellData( simData, c, r );\n        m = c();\n        if( is.null(cell) || (nrow(cell) == 0 )){\n            m$MAG = 0;\n            m$FREQ = 0;\n        }else{\n            m$MAG = max( cell$MAG );\n            m$FREQ = (nrow(cell)/nrow(simData));\n        }\n        m$ROW = r;\n        m$COLUMN = c;\n        m$maxLAT = (maxLat - (m$ROW-1)*deltaLat);\n        m$minLAT = (maxLat - m$ROW*deltaLat);\n        m$maxLON = (minLon + m$COLUMN*deltaLon);\n        m$minLON = (minLon + (m$COLUMN-1)*deltaLon);\n        m = as.data.frame( m );\n        if( is.null(mg)||(nrow(mg)==0)){\n            mg = m;\n        }else{\n            mg = rbind( mg, m );\n        }\n    }}\n    print( mg );\n    mg <<- mg;\n    gm = get_map( \"California\", zoom = 6, maptype=\"terrain\", source=\"google\" );\n    ggmap( gm, base_layer = ggplot( x=minLON, y=minLAT, data=mg ) ) + \n        geom_rect( aes( xmin=minLON, xmax=maxLON, ymin=minLAT, ymax=maxLAT, \n                        fill = I(\"firebrick1\"), alpha=(MAG^2)/64 ) ) + \n        geom_rect( aes( xmin=minLON, xmax=maxLON, ymin=minLAT, ymax=maxLAT, \n                        fill = I(\"blue\"), alpha=(FREQ*2.5) ) );\n}\n\n###\n###\n###\nmapData = function( data, zoom, size ){\n    if ( missing( zoom ) ){\n        zoom=7;\n    }\n    qmplot( LON, LAT, data=data, size=I(size),\n            color=I(\"red\"), zoom=zoom,\n            source=\"google\", maptype=\"terrain\" );\n}\n\n###\n###\n###\nrun = function(){\n    setwd( workingDirectory );\n    rawData = parseData();\n    data = structureData( rawData );\n    plotPoisMagGrid( data );\n}\n\n###\n###\n###\nquickRun = function(){\n    data = structureData( rawData );\n    plotPoisMagGrid( data );\n}",
    "created" : 1504819018251.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2201102783",
    "id" : "2BC7CDF5",
    "lastKnownWriteTime" : 1504819313,
    "last_content_update" : 1504820534930,
    "path" : "C:/Users/bennetts4/Google Drive/zCompleted_Courses/MATH3800_StochasticProcesses/Stochastics_Project/EarthquakeModelingV11.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}